{"ast":null,"code":"var util = require('./util');\nvar slice = util.slice;\nvar pluck = util.pluck;\nvar each = util.each;\nvar bind = util.bind;\nvar create = util.create;\nvar isList = util.isList;\nvar isFunction = util.isFunction;\nvar isObject = util.isObject;\nmodule.exports = {\n  createStore: createStore\n};\nvar storeAPI = {\n  version: '2.0.12',\n  enabled: false,\n  // get returns the value of the given key. If that value\n  // is undefined, it returns optionalDefaultValue instead.\n  get: function (key, optionalDefaultValue) {\n    var data = this.storage.read(this._namespacePrefix + key);\n    return this._deserialize(data, optionalDefaultValue);\n  },\n  // set will store the given value at key and returns value.\n  // Calling set with value === undefined is equivalent to calling remove.\n  set: function (key, value) {\n    if (value === undefined) {\n      return this.remove(key);\n    }\n    this.storage.write(this._namespacePrefix + key, this._serialize(value));\n    return value;\n  },\n  // remove deletes the key and value stored at the given key.\n  remove: function (key) {\n    this.storage.remove(this._namespacePrefix + key);\n  },\n  // each will call the given callback once for each key-value pair\n  // in this store.\n  each: function (callback) {\n    var self = this;\n    this.storage.each(function (val, namespacedKey) {\n      callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''));\n    });\n  },\n  // clearAll will remove all the stored key-value pairs in this store.\n  clearAll: function () {\n    this.storage.clearAll();\n  },\n  // additional functionality that can't live in plugins\n  // ---------------------------------------------------\n\n  // hasNamespace returns true if this store instance has the given namespace.\n  hasNamespace: function (namespace) {\n    return this._namespacePrefix == '__storejs_' + namespace + '_';\n  },\n  // createStore creates a store.js instance with the first\n  // functioning storage in the list of storage candidates,\n  // and applies the the given mixins to the instance.\n  createStore: function () {\n    return createStore.apply(this, arguments);\n  },\n  addPlugin: function (plugin) {\n    this._addPlugin(plugin);\n  },\n  namespace: function (namespace) {\n    return createStore(this.storage, this.plugins, namespace);\n  }\n};\nfunction _warn() {\n  var _console = typeof console == 'undefined' ? null : console;\n  if (!_console) {\n    return;\n  }\n  var fn = _console.warn ? _console.warn : _console.log;\n  fn.apply(_console, arguments);\n}\nfunction createStore(storages, plugins, namespace) {\n  if (!namespace) {\n    namespace = '';\n  }\n  if (storages && !isList(storages)) {\n    storages = [storages];\n  }\n  if (plugins && !isList(plugins)) {\n    plugins = [plugins];\n  }\n  var namespacePrefix = namespace ? '__storejs_' + namespace + '_' : '';\n  var namespaceRegexp = namespace ? new RegExp('^' + namespacePrefix) : null;\n  var legalNamespaces = /^[a-zA-Z0-9_\\-]*$/; // alpha-numeric + underscore and dash\n  if (!legalNamespaces.test(namespace)) {\n    throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes');\n  }\n  var _privateStoreProps = {\n    _namespacePrefix: namespacePrefix,\n    _namespaceRegexp: namespaceRegexp,\n    _testStorage: function (storage) {\n      try {\n        var testStr = '__storejs__test__';\n        storage.write(testStr, testStr);\n        var ok = storage.read(testStr) === testStr;\n        storage.remove(testStr);\n        return ok;\n      } catch (e) {\n        return false;\n      }\n    },\n    _assignPluginFnProp: function (pluginFnProp, propName) {\n      var oldFn = this[propName];\n      this[propName] = function pluginFn() {\n        var args = slice(arguments, 0);\n        var self = this;\n\n        // super_fn calls the old function which was overwritten by\n        // this mixin.\n        function super_fn() {\n          if (!oldFn) {\n            return;\n          }\n          each(arguments, function (arg, i) {\n            args[i] = arg;\n          });\n          return oldFn.apply(self, args);\n        }\n\n        // Give mixing function access to super_fn by prefixing all mixin function\n        // arguments with super_fn.\n        var newFnArgs = [super_fn].concat(args);\n        return pluginFnProp.apply(self, newFnArgs);\n      };\n    },\n    _serialize: function (obj) {\n      return JSON.stringify(obj);\n    },\n    _deserialize: function (strVal, defaultVal) {\n      if (!strVal) {\n        return defaultVal;\n      }\n      // It is possible that a raw string value has been previously stored\n      // in a storage without using store.js, meaning it will be a raw\n      // string value instead of a JSON serialized string. By defaulting\n      // to the raw string value in case of a JSON parse error, we allow\n      // for past stored values to be forwards-compatible with store.js\n      var val = '';\n      try {\n        val = JSON.parse(strVal);\n      } catch (e) {\n        val = strVal;\n      }\n      return val !== undefined ? val : defaultVal;\n    },\n    _addStorage: function (storage) {\n      if (this.enabled) {\n        return;\n      }\n      if (this._testStorage(storage)) {\n        this.storage = storage;\n        this.enabled = true;\n      }\n    },\n    _addPlugin: function (plugin) {\n      var self = this;\n\n      // If the plugin is an array, then add all plugins in the array.\n      // This allows for a plugin to depend on other plugins.\n      if (isList(plugin)) {\n        each(plugin, function (plugin) {\n          self._addPlugin(plugin);\n        });\n        return;\n      }\n\n      // Keep track of all plugins we've seen so far, so that we\n      // don't add any of them twice.\n      var seenPlugin = pluck(this.plugins, function (seenPlugin) {\n        return plugin === seenPlugin;\n      });\n      if (seenPlugin) {\n        return;\n      }\n      this.plugins.push(plugin);\n\n      // Check that the plugin is properly formed\n      if (!isFunction(plugin)) {\n        throw new Error('Plugins must be function values that return objects');\n      }\n      var pluginProperties = plugin.call(this);\n      if (!isObject(pluginProperties)) {\n        throw new Error('Plugins must return an object of function properties');\n      }\n\n      // Add the plugin function properties to this store instance.\n      each(pluginProperties, function (pluginFnProp, propName) {\n        if (!isFunction(pluginFnProp)) {\n          throw new Error('Bad plugin property: ' + propName + ' from plugin ' + plugin.name + '. Plugins should only return functions.');\n        }\n        self._assignPluginFnProp(pluginFnProp, propName);\n      });\n    },\n    // Put deprecated properties in the private API, so as to not expose it to accidential\n    // discovery through inspection of the store object.\n\n    // Deprecated: addStorage\n    addStorage: function (storage) {\n      _warn('store.addStorage(storage) is deprecated. Use createStore([storages])');\n      this._addStorage(storage);\n    }\n  };\n  var store = create(_privateStoreProps, storeAPI, {\n    plugins: []\n  });\n  store.raw = {};\n  each(store, function (prop, propName) {\n    if (isFunction(prop)) {\n      store.raw[propName] = bind(store, prop);\n    }\n  });\n  each(storages, function (storage) {\n    store._addStorage(storage);\n  });\n  each(plugins, function (plugin) {\n    store._addPlugin(plugin);\n  });\n  return store;\n}","map":{"version":3,"names":["util","require","slice","pluck","each","bind","create","isList","isFunction","isObject","module","exports","createStore","storeAPI","version","enabled","get","key","optionalDefaultValue","data","storage","read","_namespacePrefix","_deserialize","set","value","undefined","remove","write","_serialize","callback","self","val","namespacedKey","call","replace","_namespaceRegexp","clearAll","hasNamespace","namespace","apply","arguments","addPlugin","plugin","_addPlugin","plugins","_warn","_console","console","fn","warn","log","storages","namespacePrefix","namespaceRegexp","RegExp","legalNamespaces","test","Error","_privateStoreProps","_testStorage","testStr","ok","e","_assignPluginFnProp","pluginFnProp","propName","oldFn","pluginFn","args","super_fn","arg","i","newFnArgs","concat","obj","JSON","stringify","strVal","defaultVal","parse","_addStorage","seenPlugin","push","pluginProperties","name","addStorage","store","raw","prop"],"sources":["E:/Github/react_rent/react_rent/node_modules/store/src/store-engine.js"],"sourcesContent":["var util = require('./util')\nvar slice = util.slice\nvar pluck = util.pluck\nvar each = util.each\nvar bind = util.bind\nvar create = util.create\nvar isList = util.isList\nvar isFunction = util.isFunction\nvar isObject = util.isObject\n\nmodule.exports = {\n\tcreateStore: createStore\n}\n\nvar storeAPI = {\n\tversion: '2.0.12',\n\tenabled: false,\n\t\n\t// get returns the value of the given key. If that value\n\t// is undefined, it returns optionalDefaultValue instead.\n\tget: function(key, optionalDefaultValue) {\n\t\tvar data = this.storage.read(this._namespacePrefix + key)\n\t\treturn this._deserialize(data, optionalDefaultValue)\n\t},\n\n\t// set will store the given value at key and returns value.\n\t// Calling set with value === undefined is equivalent to calling remove.\n\tset: function(key, value) {\n\t\tif (value === undefined) {\n\t\t\treturn this.remove(key)\n\t\t}\n\t\tthis.storage.write(this._namespacePrefix + key, this._serialize(value))\n\t\treturn value\n\t},\n\n\t// remove deletes the key and value stored at the given key.\n\tremove: function(key) {\n\t\tthis.storage.remove(this._namespacePrefix + key)\n\t},\n\n\t// each will call the given callback once for each key-value pair\n\t// in this store.\n\teach: function(callback) {\n\t\tvar self = this\n\t\tthis.storage.each(function(val, namespacedKey) {\n\t\t\tcallback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''))\n\t\t})\n\t},\n\n\t// clearAll will remove all the stored key-value pairs in this store.\n\tclearAll: function() {\n\t\tthis.storage.clearAll()\n\t},\n\n\t// additional functionality that can't live in plugins\n\t// ---------------------------------------------------\n\n\t// hasNamespace returns true if this store instance has the given namespace.\n\thasNamespace: function(namespace) {\n\t\treturn (this._namespacePrefix == '__storejs_'+namespace+'_')\n\t},\n\n\t// createStore creates a store.js instance with the first\n\t// functioning storage in the list of storage candidates,\n\t// and applies the the given mixins to the instance.\n\tcreateStore: function() {\n\t\treturn createStore.apply(this, arguments)\n\t},\n\t\n\taddPlugin: function(plugin) {\n\t\tthis._addPlugin(plugin)\n\t},\n\t\n\tnamespace: function(namespace) {\n\t\treturn createStore(this.storage, this.plugins, namespace)\n\t}\n}\n\nfunction _warn() {\n\tvar _console = (typeof console == 'undefined' ? null : console)\n\tif (!_console) { return }\n\tvar fn = (_console.warn ? _console.warn : _console.log)\n\tfn.apply(_console, arguments)\n}\n\nfunction createStore(storages, plugins, namespace) {\n\tif (!namespace) {\n\t\tnamespace = ''\n\t}\n\tif (storages && !isList(storages)) {\n\t\tstorages = [storages]\n\t}\n\tif (plugins && !isList(plugins)) {\n\t\tplugins = [plugins]\n\t}\n\n\tvar namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '')\n\tvar namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null)\n\tvar legalNamespaces = /^[a-zA-Z0-9_\\-]*$/ // alpha-numeric + underscore and dash\n\tif (!legalNamespaces.test(namespace)) {\n\t\tthrow new Error('store.js namespaces can only have alphanumerics + underscores and dashes')\n\t}\n\t\n\tvar _privateStoreProps = {\n\t\t_namespacePrefix: namespacePrefix,\n\t\t_namespaceRegexp: namespaceRegexp,\n\n\t\t_testStorage: function(storage) {\n\t\t\ttry {\n\t\t\t\tvar testStr = '__storejs__test__'\n\t\t\t\tstorage.write(testStr, testStr)\n\t\t\t\tvar ok = (storage.read(testStr) === testStr)\n\t\t\t\tstorage.remove(testStr)\n\t\t\t\treturn ok\n\t\t\t} catch(e) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t},\n\n\t\t_assignPluginFnProp: function(pluginFnProp, propName) {\n\t\t\tvar oldFn = this[propName]\n\t\t\tthis[propName] = function pluginFn() {\n\t\t\t\tvar args = slice(arguments, 0)\n\t\t\t\tvar self = this\n\n\t\t\t\t// super_fn calls the old function which was overwritten by\n\t\t\t\t// this mixin.\n\t\t\t\tfunction super_fn() {\n\t\t\t\t\tif (!oldFn) { return }\n\t\t\t\t\teach(arguments, function(arg, i) {\n\t\t\t\t\t\targs[i] = arg\n\t\t\t\t\t})\n\t\t\t\t\treturn oldFn.apply(self, args)\n\t\t\t\t}\n\n\t\t\t\t// Give mixing function access to super_fn by prefixing all mixin function\n\t\t\t\t// arguments with super_fn.\n\t\t\t\tvar newFnArgs = [super_fn].concat(args)\n\n\t\t\t\treturn pluginFnProp.apply(self, newFnArgs)\n\t\t\t}\n\t\t},\n\n\t\t_serialize: function(obj) {\n\t\t\treturn JSON.stringify(obj)\n\t\t},\n\n\t\t_deserialize: function(strVal, defaultVal) {\n\t\t\tif (!strVal) { return defaultVal }\n\t\t\t// It is possible that a raw string value has been previously stored\n\t\t\t// in a storage without using store.js, meaning it will be a raw\n\t\t\t// string value instead of a JSON serialized string. By defaulting\n\t\t\t// to the raw string value in case of a JSON parse error, we allow\n\t\t\t// for past stored values to be forwards-compatible with store.js\n\t\t\tvar val = ''\n\t\t\ttry { val = JSON.parse(strVal) }\n\t\t\tcatch(e) { val = strVal }\n\n\t\t\treturn (val !== undefined ? val : defaultVal)\n\t\t},\n\t\t\n\t\t_addStorage: function(storage) {\n\t\t\tif (this.enabled) { return }\n\t\t\tif (this._testStorage(storage)) {\n\t\t\t\tthis.storage = storage\n\t\t\t\tthis.enabled = true\n\t\t\t}\n\t\t},\n\n\t\t_addPlugin: function(plugin) {\n\t\t\tvar self = this\n\n\t\t\t// If the plugin is an array, then add all plugins in the array.\n\t\t\t// This allows for a plugin to depend on other plugins.\n\t\t\tif (isList(plugin)) {\n\t\t\t\teach(plugin, function(plugin) {\n\t\t\t\t\tself._addPlugin(plugin)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Keep track of all plugins we've seen so far, so that we\n\t\t\t// don't add any of them twice.\n\t\t\tvar seenPlugin = pluck(this.plugins, function(seenPlugin) {\n\t\t\t\treturn (plugin === seenPlugin)\n\t\t\t})\n\t\t\tif (seenPlugin) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tthis.plugins.push(plugin)\n\n\t\t\t// Check that the plugin is properly formed\n\t\t\tif (!isFunction(plugin)) {\n\t\t\t\tthrow new Error('Plugins must be function values that return objects')\n\t\t\t}\n\n\t\t\tvar pluginProperties = plugin.call(this)\n\t\t\tif (!isObject(pluginProperties)) {\n\t\t\t\tthrow new Error('Plugins must return an object of function properties')\n\t\t\t}\n\n\t\t\t// Add the plugin function properties to this store instance.\n\t\t\teach(pluginProperties, function(pluginFnProp, propName) {\n\t\t\t\tif (!isFunction(pluginFnProp)) {\n\t\t\t\t\tthrow new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')\n\t\t\t\t}\n\t\t\t\tself._assignPluginFnProp(pluginFnProp, propName)\n\t\t\t})\n\t\t},\n\t\t\n\t\t// Put deprecated properties in the private API, so as to not expose it to accidential\n\t\t// discovery through inspection of the store object.\n\t\t\n\t\t// Deprecated: addStorage\n\t\taddStorage: function(storage) {\n\t\t\t_warn('store.addStorage(storage) is deprecated. Use createStore([storages])')\n\t\t\tthis._addStorage(storage)\n\t\t}\n\t}\n\n\tvar store = create(_privateStoreProps, storeAPI, {\n\t\tplugins: []\n\t})\n\tstore.raw = {}\n\teach(store, function(prop, propName) {\n\t\tif (isFunction(prop)) {\n\t\t\tstore.raw[propName] = bind(store, prop)\t\t\t\n\t\t}\n\t})\n\teach(storages, function(storage) {\n\t\tstore._addStorage(storage)\n\t})\n\teach(plugins, function(plugin) {\n\t\tstore._addPlugin(plugin)\n\t})\n\treturn store\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}